# The MIT License (MIT)
# Copyright © 2021 Yuma Rao

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated 
# documentation files (the “Software”), to deal in the Software without restriction, including without limitation 
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of 
# the Software.

# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
# DEALINGS IN THE SOFTWARE.

#!/usr/bin/env python3
import os
import sys
import time
import random
import threading
from bittensor._subtensor.subtensor_impl import Subtensor
import yaml
import bittensor
import argparse
from rich.console import Console
from rich.table import Table
from rich.prompt import Confirm
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor
import utils

from loguru import logger
logger = logger.opt(colors=True)

def status( config ):      
    total_stake = 0.0
    total_rank = 0.0
    total_trust = 0.0
    total_consensus = 0.0
    total_incentive = 0.0
    total_dividends = 0.0
    total_emission = 0.0  
    def get_row( droplet ): 
        try:
            connection = utils.connection_for_machine( config, droplet )
            can_connect_bool = utils.can_connect( config, connection ) 
            subtensor = bittensor.subtensor()
            connect_str = '[bold green] YES' if can_connect_bool else '[bold red] NO'
            hotkey_str = '[yellow] None'
            coldkeypub_str = '[yellow] None'
            branch_str = '[yellow] None'
            is_installed_str = '[bold red] No'
            is_running_str = '[bold red] No'
            is_registered_str = '[bold red] No'
            is_running = False
            installed = False
            nonlocal total_stake
            nonlocal total_rank
            nonlocal total_trust
            nonlocal total_consensus
            nonlocal total_incentive
            nonlocal total_dividends
            nonlocal total_emission  
            is_registered = False
            if can_connect_bool:
                try:
                    hotkey = utils.get_hotkey( config, connection ); hotkey_str = hotkey if hotkey != None else '[yellow] None'
                except Exception as e:
                    hotkey_str = '[yellow] None'; logger.error('{}: Failed to pull hotkey error = {}', droplet.name, e )
            if can_connect_bool:
                try:
                    coldkeypub = utils.get_coldkeypub( config, connection )
                    coldkeypub_str = coldkeypub[0:10] if coldkeypub != None else '[yellow] None'
                except Exception as e:
                    logger.error('{}: Failed to pull coldkey error = {}', droplet.name, e )
            if can_connect_bool:
                try:
                    branch = utils.get_branch( config, connection )
                    branch_str = branch if branch != None else '[yellow] None'
                except Exception as e:
                    logger.error('{}: Failed to pull branch error = {}', droplet.name, e )
            if can_connect_bool and branch != None:
                try:
                    installed = utils.is_installed( config, connection )
                    is_installed_str =  '[bold green] Yes' if installed else '[bold red] No'
                except Exception as e:
                    logger.error('{}: Failed to pull install status error = {}', droplet.name, e)
            if can_connect_bool and installed:
                try:
                    is_running = utils.is_script_running( config, connection )
                    is_running_str =  '[bold green] Yes' if is_running else '[bold red] No'
                except Exception as e:
                    logger.error('{}: Failed to pull running status: error = {}', droplet.name, e )
            try:
                neuron = subtensor.neuron_for_pubkey( hotkey_str )
                if not neuron.is_null:
                    is_registered = True
                    is_registered_str =  '[bold green] Yes' if is_registered else '[bold red] No'
            except:
                pass

            if is_registered:
                metrics = [
                    str( neuron.uid ), 
                    '{:.5f}'.format( neuron.stake),
                    '{:.5f}'.format( neuron.rank), 
                    '{:.5f}'.format( neuron.trust), 
                    '{:.5f}'.format( neuron.consensus), 
                    '{:.5f}'.format( neuron.incentive),
                    '{:.5f}'.format( neuron.dividends),
                    '{:.5f}'.format( neuron.emission),
                    str(neuron.last_update),
                    str( neuron.active ), 
                ]
                total_stake += neuron.stake
                total_rank += neuron.rank
                total_trust += neuron.trust
                total_consensus += neuron.consensus
                total_incentive += neuron.incentive
                total_dividends += neuron.dividends
                total_emission += neuron.emission
            else:
                metrics = ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-']

            row = [ str(droplet.name), str(droplet.tags[0]), str(droplet.ip_address), str(droplet.region['name']), str(droplet.size_slug), str(connect_str), branch_str, is_installed_str, is_registered_str, is_running_str] + metrics + [coldkeypub_str, hotkey_str] 
            connection.close()
        except:
            row = [str(droplet.name),'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-']
        return row
       
    droplets = utils.get_machines( config )
    TABLE_DATA = []
    with ThreadPoolExecutor(max_workers=config.max_threads) as executor:
        TABLE_DATA = list(tqdm(executor.map(get_row, droplets), total=len(droplets)))

    TABLE_DATA = [row for row in TABLE_DATA if row != None ]
    TABLE_DATA.sort(key = lambda TABLE_DATA: TABLE_DATA[0])

    table = Table(show_footer=False)
    table.title = (
        "[bold white]Marius" 
    )
    table.add_column("[overline white]Name",  str(len(config.machines)), footer_style = "overline white", style='white')
    table.add_column("[overline white]TAG", style='white')
    table.add_column("[overline white]IP", style='blue')
    table.add_column("[overline white]Location", style='yellow')
    table.add_column("[overline white]Size", style='green')
    table.add_column("[overline white]Connected", style='green')
    table.add_column("[overline white]Branch", style='bold purple')
    table.add_column("[overline white]Installed")
    table.add_column("[overline white]Registered")
    table.add_column("[overline white]Running")

    table.add_column("[overline white]Uid", footer_style = "overline white", style='yellow')
    table.add_column("[overline white]Stake", '{:.5f}'.format(total_stake), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Rank", '{:.5f}'.format(total_rank), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Trust", '{:.5f}'.format(total_trust), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Consensus", '{:.5f}'.format(total_consensus), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Incentive", '{:.5f}'.format(total_incentive), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Dividends", '{:.5f}'.format(total_dividends), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Emission", '{:.5f}'.format(total_emission), footer_style = "overline white", justify='right', style='green', no_wrap=True)
    table.add_column("[overline white]Lastupdate (blocks)", justify='right', no_wrap=True)
    table.add_column("[overline white]Active", justify='right', style='green', no_wrap=True)

    table.add_column("[overline white]Coldkey", style='bold blue', no_wrap=False)
    table.add_column("[overline white]Hotkey", style='blue', no_wrap=False)
    table.show_footer = True

    for row in TABLE_DATA:
        table.add_row(*row)
    table.box = None
    table.pad_edge = False
    table.width = None
    console = Console()
    console.print(table)

def create ( config ):
    droplets = utils.get_machines ( config )
    existing_droplets = [droplet.name for droplet in droplets]
    to_create = config.machines
    if config.names != None:
        to_create = config.names

    def _create(name):
        try:
            if name not in existing_droplets:
                if not utils.create_droplet(config, name): logger.error('<blue>{}</blue>: Failed to create droplet with name.', name); return
                else: logger.success('<blue>{}</blue>: Created droplet.', name)
            else:
                logger.success('<blue>{}</blue>: Droplet already exists.', name)
        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE CREATE', name)

    with ThreadPoolExecutor(max_workers=config.max_threads) as executor:
        tqdm(executor.map(_create, to_create), total=len(to_create))

def checkout ( config ):
    def _checkout ( droplet ):
        try:
            name = droplet.name
            branch = config.machines[name].branch
            connection = utils.connection_for_machine( config, droplet )

            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            if utils.make_bittensor_dir( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to make bittensor dirs.', name); return
            else: logger.success('<blue>{}</blue>: Made bittensor dirs.', name)

            if utils.remove_bittensor_installation( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to remove previous bittensor installation', name); return
            else: logger.success('<blue>{}</blue>: Remove previous bittensor installation', name)

            if utils.git_clone_bittensor( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to clone bittensor', name); return
            else: logger.success('<blue>{}</blue>: Cloned bittensor', name)

            if utils.git_checkout_bittensor( config, connection, branch ).failed: logger.error('<blue>{}</blue>: Failed to checkout bittensor branch: {}', name, branch); return
            else: logger.success('<blue>{}</blue>: Checked out bittensor branch', name)

            branch_result = utils.git_branch_bittensor( config, connection )
            if branch_result.failed: logger.error("{}: Failed to get branch", name); return
            else: logger.success('<blue>{}</blue>: Branch set to: {}', name,  branch_result.stdout.strip())

        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE CHECKOUT ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor(max_workers=config.max_threads) as executor:
        tqdm(executor.map(_checkout, droplets), total=len(droplets))

def wallet( config ):
    def _wallet(droplet):
        try:
            name = droplet.name
            wallet = bittensor.wallet( name = config.machines[droplet.name].coldkey, hotkey = name )
            connection = utils.connection_for_machine( config, droplet )

            if not wallet.hotkey_file.exists_on_device():
                wallet.create_new_hotkey( use_password=False, overwrite=False )
            
            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            if not wallet.hotkey_file.exists_on_device(): logger.error('<blue>{}</blue>: Wallet does not have hotkey: {}', name, wallet.hotkey_file.path); return
            else: logger.success('<blue>{}</blue>: Found hotkey: {}', name, name)

            if not wallet.coldkeypub_file.exists_on_device(): logger.error('<blue>{}</blue>: Wallet does not have coldkeypub: {}', name, wallet.coldkeypub_file.path); return
            else: logger.success('<blue>{}</blue>: Found coldkeypub: {}', name, wallet.coldkeypub_file.path)
            
            if utils.make_wallet_dirs( config, connection ).failed: logger.error('<blue>{}</blue>: Error creating wallet dirs', name); return
            else: logger.success('<blue>{}</blue>: Created wallet directories', name)

            if utils.copy_hotkey( config, connection, wallet ).failed: logger.error('<blue>{}</blue>: Error coping hotkey.', name); return
            else: logger.success('<blue>{}</blue>: Copied hotkey to dir: {}', name, '/root/.bittensor/wallets/default/hotkeys/default')

            if utils.copy_coldkeypub(config, connection, wallet).failed: logger.error('<blue>{}</blue>: Error copy coldkey', name); return
            else: logger.success('<blue>{}</blue>: Copied coldkey to dir: {}', name, '/root/.bittensor/wallets/default/coldkeypub.txt')

            if utils.get_hotkey( config, connection ) == None: logger.error('<blue>{}</blue>: Failed to retrieve hotkey from {}', name, connection.host); return
            else: logger.success('<blue>{}</blue>: Could retrieve hotkey: {}', name, utils.get_hotkey( config, connection ) )

            if utils.get_coldkeypub( config, connection ) == None: logger.error('<blue>{}</blue>: Failed to retrieve coldkeypub from {}', name, connection.host); return
            else: logger.success('<blue>{}</blue>: Could retrieve coldkeypub: {}', name, utils.get_coldkeypub( config, connection ) )

        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE WALLET ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor(max_workers=config.max_threads) as executor:
        tqdm(executor.map(_wallet, droplets), total=len(droplets))

def install( config ):
    def _install( droplet ):
        try:
            name = droplet.name
            connection = utils.connection_for_machine( config, droplet )

            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            if utils.install_swapspace(config, connection ).failed: logger.success('<blue>{}</blue>: Swapspace already installed', name)
            else: logger.success('<blue>{}</blue>: Installed swapspace.', name)

            if utils.install_python_deps( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to install python deps', name); return
            else: logger.success('<blue>{}</blue>: Python deps installation successful.', name)

            if utils.install_npm(config, connection ).failed: logger.error('<blue>{}</blue> Failed to install npm', name); return
            else: logger.success('<blue>{}</blue>: Installed npm.', name)

            if utils.install_pm2(config, connection ).failed: logger.error('<blue>{}</blue>: Failed to install pm2', name); return
            else: logger.success('<blue>{}</blue>: Installed pm2.', name)

            if utils.install_python( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to install python', name); return
            else: logger.success('<blue>{}</blue>: Python installation successful.', name)

            if utils.install_bittensor_deps( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to install bittensor deps', name); return
            else: logger.success('<blue>{}</blue>: Bittensor deps installation successful.', name)

            if utils.install_bittensor( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to install bittensor', name)
            else: logger.success('<blue>{}</blue>: Bittensor installation successful.', name)

            if not utils.is_installed( config, connection ): logger.error('<blue>{}</blue>: Bittensor is not installed', name); return
            else: logger.success('<blue>{}</blue>: Bittensor is installed.', name)

            if not utils.start_subtensor( config, connection ): logger.error('<blue>{}</blue>: Subtensor failed to start', name); return
            else: logger.success('<blue>{}</blue>: Local Subtensor is running.', name)

        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE INSTALLING ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor(max_workers=config.max_threads) as executor:
        tqdm(executor.map(_install, droplets), total=len(droplets))

def logs( config ):
    def _logs( droplet ):
        try:
            name = droplet.name
            connection = utils.connection_for_machine( config, droplet )

            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            logger.success( "{}: {}".format( name, utils.get_logs( config, connection ) ) )
        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE LOGS ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor( max_workers=config.max_threads ) as executor:
        tqdm(executor.map(_logs, droplets), total=len(droplets))

def register_remote( config ):
    logger.success('Registering droplets remote. ')

    def _do_register( droplet ):
        try:
            name = droplet.name
            logger.success('<blue>{}</blue>: Registering ', name)
            connection = utils.connection_for_machine( config, droplet )

            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            utils.copy_registration_tools( config, connection )

            # Kill previous.
            utils.kill_fast_register( config, connection )
            logger.success('<blue>{}</blue>: Killed previsou registration.', name)

            if utils.run_registration_tools_default( config, connection ).failed: logger.error('<blue>{}</blue>: Failed to run registration.', name); return
            else: logger.success('<blue>{}</blue>: Registration successful', name)

        except Exception as e:
            logger.exception( e )

        finally:
            # Kill fast registration.
            utils.kill_fast_register( config, connection )
            logger.success('<blue>{}</blue>: Killed fast final register', name)

            logger.success('<blue>{}</blue>: DONE Registering ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor( max_workers=config.max_threads ) as executor:
        tqdm(executor.map( _do_register, droplets ), total=len(droplets))

    logger.success('<blue>!!</blue>: All Registered ')

def clean( config ):
    logger.success('Cleaning droplets ')

    def _do_clean( droplet ):
        try:
            name = droplet.name
            logger.success('<blue>{}</blue>: Cleaning ', name)
            connection = utils.connection_for_machine( config, droplet )
            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)
            if utils.stop_script( config, connection ).failed: pass
            else: logger.success('<blue>{}</blue>: Stopped miner.', name)
            if not utils.clear_cache( config, connection ): logger.error('<blue>{}</blue>: Failed to clear cache', name); return
            else: logger.success('<blue>{}</blue>: Cleared cache', name)
            if not utils.kill_fast_register( config, connection ): logger.error('<blue>{}</blue>: Failed to reboot kill_fast_register', name); return
            else: logger.success('<blue>{}</blue>: kill_fast_register on droplet', name)
            if utils.start_command( config, connection, name, config.machines[droplet.name].command ).failed: logger.error('<blue>{}</blue>: Failed to start miner', name); return
            else: logger.success('<blue>{}</blue>: Started miner', name)
            if not utils.is_script_running( config, connection ): logger.error('Failed to start miner, script not running', name); return
            else: logger.success('<blue>{}</blue>: Script running', name)
        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE Cleaning ', name)
            connection.close()
    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor( max_workers=config.max_threads ) as executor:
        tqdm(executor.map( _do_clean, droplets ), total=len(droplets))
    logger.success('<blue>!!</blue>: All cleaned ')


def reboot( config ):
    logger.success('Registering droplets remote. ')

    def _do_reboot( droplet ):
        try:
            name = droplet.name
            logger.success('<blue>{}</blue>: Rebooting ', name)
            connection = utils.connection_for_machine( config, droplet )
            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            if utils.stop_script( config, connection ).failed: pass
            else: logger.success('<blue>{}</blue>: Stopped miner.', name)

            if not utils.clear_cache( config, connection ): logger.error('<blue>{}</blue>: Failed to clear cache', name); return
            else: logger.success('<blue>{}</blue>: Cleared cache', name)

            if not utils.run_reboot( config, connection ): logger.error('<blue>{}</blue>: Failed to reboot droplet', name); return
            else: logger.success('<blue>{}</blue>: Rebooted droplet', name)

        except Exception as e:
            logger.exception( e )

        finally:
            logger.success('<blue>{}</blue>: DONE Rebooting ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor( max_workers=config.max_threads ) as executor:
        tqdm(executor.map( _do_reboot, droplets ), total=len(droplets))

    logger.success('<blue>!!</blue>: All Rebooted ')



def fast_register( config ):
    def _do_register( droplet ):
        try:
            # Make connection.
            name = droplet.name
            wallet = bittensor.wallet( config )
            logger.debug('<blue>{}</blue>: Registering ', name)
            connection = utils.connection_for_machine( config, droplet )
            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.debug('<blue>{}</blue>: Made connection to droplet', name)

            # Copy wallet.
            if not wallet.hotkey_file.exists_on_device(): logger.error('<blue>{}</blue>: Wallet does not have hotkey: {}', name, wallet.hotkey_file.path); return
            else: logger.debug('<blue>{}</blue>: Found hotkey: {}', name, name)

            if not wallet.coldkeypub_file.exists_on_device(): logger.error('<blue>{}</blue>: Wallet does not have coldkeypub: {}', name, wallet.coldkeypub_file.path); return
            else: logger.debug('<blue>{}</blue>: Found coldkeypub: {}', name, wallet.coldkeypub_file.path)
            
            if utils.make_fast_wallet_dirs( config, connection ).failed: logger.error('<blue>{}</blue>: Error creating wallet dirs', name); return
            else: logger.debug('<blue>{}</blue>: Created wallet directories', name)

            if utils.copy_fast_hotkey( config, connection, wallet).failed: logger.error('<blue>{}</blue>: Error coping hotkey.', name); return
            else: logger.debug('<blue>{}</blue>: Copied hotkey to dir: {}', name, '/root/.bittensor/wallets/fast/hotkeys/fast')

            if utils.copy_fast_coldkeypub(config, connection, wallet).failed: logger.error('<blue>{}</blue>: Error copy coldkey', name); return
            else: logger.debug('<blue>{}</blue>: Copied coldkey to dir: {}', name, '/root/.bittensor/wallets/fast/coldkeypub.txt')

            if utils.get_fast_hotkey( config, connection ) == None: logger.error('<blue>{}</blue>: Failed to retrieve hotkey from {}', name, connection.host); return
            else: logger.debug('<blue>{}</blue>: Could retrieve hotkey: {}', name, utils.get_fast_hotkey( config, connection ) )

            if utils.get_fast_coldkeypub( config, connection ) == None: logger.error('<blue>{}</blue>: Failed to retrieve coldkeypub from {}', name, connection.host); return
            else: logger.debug('<blue>{}</blue>: Could retrieve coldkeypub: {}', name, utils.get_fast_coldkeypub( config, connection ) )

            # Copy speed registration tools.
            utils.copy_registration_tools( config, connection )

            # Kill previous.
            utils.kill_fast_register( config, connection )
            logger.debug('<blue>{}</blue>: Killed previous registration.', name)

            # Run registration tool.
            utils.run_registration_tools( config, connection )
            logger.debug('<blue>{}</blue>: Started fast registration...', name)

            start = time.time()
            while time.time() - start < config.timeout:
                sub = bittensor.subtensor()
                wallet_neuron = sub.neuron_for_pubkey( wallet.hotkey.ss58_address )
                if not wallet_neuron.is_null:
                    utils.kill_fast_register( config, connection )
                    logger.success('<blue>{}</blue>: Killed fast register with success.', name)
                    break
                else:
                    #logger.success('<blue>{}</blue>: Waiting on registration: remaining: {}/{}', name, time.time() - start, config.timeout)
                    time.sleep(2)
                    continue

        except Exception as e:
            logger.debug( e )

        finally:
            # Kill fast registration.
            utils.kill_fast_register( config, connection )
            logger.debug('<blue>{}</blue>: Killed fast register on final.', name)

            logger.debug('<blue>{}</blue>: DONE Registering ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    if config.workers != -1:
        random.shuffle( droplets )
        droplets = droplets[: min( config.workers, len( droplets ) ) ]
    with ThreadPoolExecutor( max_workers = len(droplets) * 2 ) as executor:
        tqdm(executor.map( _do_register, droplets ), total=len(droplets))


def start( config ):
    droplets = utils.get_machines ( config )

    def _start(droplet):
        try:
            name = droplet.name
            connection = utils.connection_for_machine( config, droplet )

            if not utils.can_connect( config, connection ): logger.error('<blue>{}</blue>: Failed to make connection to droplet', name); return
            else: logger.success('<blue>{}</blue>: Made connection to droplet', name)

            if 'script' in config.machines[droplet.name]:
                script = config.machines[droplet.name].script
                script_path = os.path.dirname(os.path.realpath(__file__)) + "/" + script 

                utils.copy_script( connection, script_path )
                logger.success('<blue>{}</blue>: Copied script to dir: {}', name, '/root/.py')

                if utils.get_script( config, connection, script ) == None: logger.error('<blue>{}</blue>: Failed to retrieve script from {}', name, connection.host); return
                else: logger.debug('<blue>{}</blue>: Could retrieve script: \n{}', name, utils.get_script( connection, script))

                if utils.stop_script( config, connection ).failed: pass
                else: logger.success('<blue>{}</blue>: Stopped miner.', name)

                utils.clear_cache( config, connection )
                logger.success('<blue>{}</blue>: Cleared Cache.', name)

                if utils.start_script( config, connection, name).failed: logger.error('<blue>{}</blue>: Failed to start miner', name); return
                else: logger.success('<blue>{}</blue>: Started miner with args {}', name)

                if not utils.is_script_running( config, connection ): logger.error('Failed to start miner, script not running', name); return
                else: logger.success('<blue>{}</blue>: Script running', name)

            elif 'command' in config.machines[droplet.name]:
                command = config.machines[droplet.name].command

                if utils.stop_script( config, connection ).failed: pass
                else: logger.success('<blue>{}</blue>: Stopped miner.', name)

                if utils.start_command( config, connection, name, command ).failed: logger.error('<blue>{}</blue>: Failed to start miner', name); return
                else: logger.success('<blue>{}</blue>: Started miner', name)

                if not utils.is_script_running( config, connection ): logger.error('Failed to start miner, script not running', name); return
                else: logger.success('<blue>{}</blue>: Script running', name)

            else:
                logger.error('No command or script', name); return

        except Exception as e:
            logger.exception( e )
        finally:
            logger.success('<blue>{}</blue>: DONE STARTING ', name)
            connection.close()

    droplets = utils.get_machines ( config )
    with ThreadPoolExecutor(max_workers=config.max_threads) as executor:
        tqdm(executor.map(_start, droplets), total=len(droplets))


def monit( config ):
    droplets = utils.get_machines ( config )
    while True:
        status ( config )
        try:
            random.shuffle( droplets )
            with bittensor.__console__.status(":satellite: Monitoring.") as console_status:
                for i,droplet in enumerate(droplets):
                    console_status.update( ":satellite: Monitoring. current: {} ({}/{})".format( droplet.name, i, len( droplets )))
                    name = droplet.name
                    logger.debug('<white>{}</white>: Begin Monit', name)
                    subtensor = bittensor.subtensor()
                    connection = utils.connection_for_machine( config, droplet )
                    logger.debug('<white>{}</white>: Made connection', name)
                    hotkey = utils.get_hotkey( config, connection )
                    logger.debug('<white>{}</white>: Got hotkey: {}', name, hotkey)
                    coldkeypub = utils.get_coldkeypub( config, connection )
                    logger.debug('<white>{}</white>: Got coldkey: {}', name, coldkeypub)
                    neuron = subtensor.neuron_for_pubkey( hotkey )
                    logger.debug('<white>{}</white>: Got neuron: {}', name, neuron)

                    if neuron.is_null:
                        console_status.update( ":satellite: Monitoring. current: {} ({}/{}). Registering ... ".format( droplet.name, i, len( droplets )))
                        utils.stop_script( config, connection )
                        config.wallet.name = config.machines[droplet.name].coldkey
                        config.wallet.hotkey = name
                        config.timeout = 5
                        fast_register( config )

                    if neuron.active == 0 or not utils.is_script_running( config, connection ):
                        console_status.update( ":satellite: Monitoring. current: {} ({}/{}). Restarting ... ".format( droplet.name, i, len( droplets )))
                        utils.stop_script( config, connection )
                        command = config.machines[name].command
                        utils.start_command( config, connection, name, command)
                        logger.debug('<white>{}</white>: Started', name)
                    
        except KeyboardInterrupt:
            break
        except Exception as e:
            logger.exception('Monit error: {}', e)
    
def get_config(): 
    parser = argparse.ArgumentParser(description="marius", usage="marius <command> <command args>", add_help=True)
    parser._positionals.title = "commands"
    command_parsers = parser.add_subparsers( dest='command' )
    parser.add_argument ("-c", '--config', dest='config_file', type=str, required=False, help="Config file to use", default='default')
    parser.add_argument ('-d', '--debug',  dest='debug', action='store_true', help='''Set debug''', default=False)
    parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    
    deploy_parser = command_parsers.add_parser('deploy', help='''Deploy entire cluster''')
    deploy_parser.add_argument ("-c", '--config', dest='config_file', type=str, required=False, help="Config file to use", default='default')
    deploy_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    deploy_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    deploy_parser.add_argument ('-p', "--procs", dest='procs', type=int, required=False, help="A list of nodes (hostnames) the selected command should operate on", default=5)

    monit_parser = command_parsers.add_parser('monit', help='''Monitor cluster''')
    monit_parser.add_argument ("-c", '--sconfig', dest='config_file', type=str, required=False, help="Config file to use", default='default')
    monit_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    monit_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    monit_parser.add_argument ('-p', "--procs", dest='procs', type=int, required=False, help="A list of nodes (hostnames) the selected command should operate on", default=5)
    monit_parser.add_argument ('-t', "--timeout", dest='timeout', type=int, required=False, help="Default registration timeout.", default=60*60*2)
    monit_parser.add_argument ('-w', "--workers", dest='workers', type=int, required=False, help="Number of workers to use for registering, -1 for all.", default=-1)
    bittensor.wallet.add_args( monit_parser )

    create_parser = command_parsers.add_parser('create', help='''Create miners''')
    create_parser.add_argument ("-c", '--config', dest='config_file', type=str, required=False, help="Config file to use", default='default')
    create_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    create_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    
    status_parser = command_parsers.add_parser('status', help='''Show mining overview''')
    status_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    status_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    status_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    
    install_parser = command_parsers.add_parser('install', help='''install''')
    install_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    install_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    install_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    install_parser.add_argument ('-p', "--procs", dest='procs', type=int, required=False, help="A list of nodes (hostnames) the selected command should operate on", default=5)

    checkout_parser = command_parsers.add_parser('checkout', help='''checkout''')
    checkout_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    checkout_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    checkout_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")

    wallet_parser = command_parsers.add_parser('wallet', help='''wallet''')
    wallet_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    wallet_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    wallet_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")

    reboot_parser = command_parsers.add_parser('reboot', help='''reboot''')
    reboot_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    reboot_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    reboot_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")

    clean_parser = command_parsers.add_parser('clean', help='''clean''')
    clean_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    clean_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    clean_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")

    register_parser = command_parsers.add_parser('register', help='''register''')
    register_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    register_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    register_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    register_parser.add_argument ('-p', "--procs", dest='procs', type=int, required=False, help="A list of nodes (hostnames) the selected command should operate on", default=10)
    register_parser.add_argument ('-t', "--timeout", dest='timeout', type=int, required=False, help="Default registration timeout.", default=60*60*24)

    fast_register_parser = command_parsers.add_parser('fast_register', help='''register''')
    fast_register_parser.add_argument ("-c", '--config', dest='config_file',type=str, required=False, help="Config file to use", default='default')
    fast_register_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    fast_register_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    fast_register_parser.add_argument ('-p', "--procs", dest='procs', type=int, required=False, help="A list of nodes (hostnames) the selected command should operate on", default=5)
    fast_register_parser.add_argument ('-t', "--timeout", dest='timeout', type=int, required=False, help="Default registration timeout.", default=60*60*2)
    fast_register_parser.add_argument ('-w', "--workers", dest='workers', type=int, required=False, help="Number of workers to use for registering, -1 for all.", default=-1)

    bittensor.wallet.add_args( fast_register_parser )

    logs_parser = command_parsers.add_parser('logs', help='''install''')
    logs_parser.add_argument ("-c", '--config', dest='config_file', type=str, required=False, help="Config file to use", default='default')
    logs_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    logs_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    logs_parser.add_argument ('-l', "--lines", dest='lines', type=int, required=False, help="Number of lines to show", default=25)

    start_parser = command_parsers.add_parser('start', help='''start''')
    start_parser.add_argument ("-c", '--config', dest='config_file', type=str, required=False, help="Config file to use", default='default')
    start_parser.add_argument ('-d', '--debug', dest='debug', action='store_true', help='''Set debug''', default=False)
    start_parser.add_argument ('-n', "--names", dest='names', type=str, nargs='*', required=False, action='store', help="A list of nodes (hostnames) the selected command should operate on")
    config = bittensor.config( parser ); 

    # Try to load without yaml extension.
    try:
        with open( 'configs/' + config.config_file + '.yaml', "r") as config_file:
            yaml_config = yaml.safe_load(config_file)
    except Exception as e:
        print('\nMarius tool requires the config file {}, but it does not exist.\n\nTry: $ cp configs/config_template.yaml configs/{} \n\n error: {}'.format(str(os.getcwd()) + '/configs/' + config.config_file + '.yaml', config.config_file ), e)
        sys.exit(0)

    yaml_config = bittensor.Config.fromDict(yaml_config)
    config.update(yaml_config)

    # Parse config and replace enviroment variables.
    def parse_env_vars( c ):
        for k in c:
            if isinstance( c[k], type(c) ):
                parse_env_vars( c[k] )
            else:
                var = str(c[k])
                if len(var.split('ENV')) > 1:
                    env_var = ''.join( var.split('ENV_')[1:] )
                    env_val = os.getenv( env_var )
                    if env_val == None: 
                        print('\nMarius tool requires you set the {} enviroment variable\n\nTry: export {}=<variable value>'.format(env_var, env_var))
                        sys.exit(0)
                    else: 
                        c[k] = env_val
    parse_env_vars( config )
    return config

def configure_logging( config ):
    logger.remove()
    if config.debug == True:
        logger.add(sys.stderr, level="TRACE", enqueue=True)
    else:
        logger.add(sys.stderr, level="INFO", enqueue=True)

def main( config ):
    configure_logging( config )
    if config.debug:
        print (config)

    # Display status.
    if config.command == 'status':
        status(config)

    # Create the cluster
    elif config.command == 'create':
        create(config)

    # Create the cluster
    elif config.command == 'clean':
        clean(config)

    # Show latest logs from cluster
    elif config.command == 'logs':
        logs(config)

    elif config.command == 'checkout':
        checkout ( config )
        if Confirm.ask("Show Status"):
            status( config )

    elif config.command == 'wallet':
        wallet ( config )
        if Confirm.ask("Show Status"):
            status( config )

    elif config.command == 'reboot':
        reboot ( config )

    elif config.command == 'register':
        register_remote ( config )
        if Confirm.ask("Show Status"):
            status( config )

    elif config.command == 'fast_register':
        fast_register ( config )
        
    # Install cluster.
    elif config.command == 'install':
        checkout ( config )
        install ( config )
        wallet ( config )
        register_remote ( config )
        if Confirm.ask("Show Status"):
            status( config )

    # Start cluster.
    elif config.command == 'start':
        start( config )
        if Confirm.ask("Show Status"):
            status( config )

    elif config.command == 'monit':
        monit( config )
    
    # Fully deploy cluster
    elif config.command == 'deploy':
        create( config )
        checkout( config )
        install ( config )
        wallet ( config )
        register_remote ( config )
        start( config )
        status( config )

    # Run all.
    else:
        create( config )
        checkout( config )
        install ( config )
        wallet ( config )
        register_remote ( config )
        start( config )
        status( config )

if __name__ == "__main__":
    config = get_config()
    #print ( config )
    main( config )



